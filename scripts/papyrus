#!/usr/bin/env python
"""
Usage:
    papyrus generate <account_type> [--address_file=<FILE>] [--address_qrcode=<FILE>]
                                    [--key_file=<FILE>] [--key_qrcode=<FILE>]
    papyrus recover ((<encrypted_key_file> | --key_file=<FILE>) | --key_qrcode=<FILE> | --key=<STRING> | [-])
                    (<decrypted_key_file> | --decrypted_key_qrcode=<FILE> | [--stdout --stdout_qrcode])
    papyrus --version
    papyrus --help

Arguments:
    <account_type>        type of account (ethereum or bitcoin)
    <encrypted_key_file>  path to file containing encrypted key
                          use a single '-' to accept data through stdin
    <decrypted_key_file>  path to file for outputting decrypted key

Options:
    --address_file=<FILE>          file to be used for generated address
    --address_qrcode=<FILE>        file to be used to save a QR code of the generated address
    --key=<STRING>                 STRING containing encrypted private key
    --key_file=<FILE>              file to be used for encrypted private key data
    --key_qrcode=<FILE>            file to be used for encrypted private key data in QR code form
    --decrypted_key_qrcode=<FILE>  file to be used for decrypted private key data in QR code form
    --stdout                       use stdout to display decrypted data
    --stdout_qrcode                display in-terminal qrcode of the decrypted data
    -h --help                      display this help

Be extremely careful using the --stdout flag. Using this flag will display your decrypted data in the terminal.
"""

import sys
import getpass
import qrcode
import qrtools
import qrcode_terminal

from docopt import docopt
from blessings import Terminal

from lockbox import decrypt

from papyrus import (BitcoinAccount,
                     EthereumAccount,
                     PapyrusException,
                     )
from papyrus._version import get_versions

VERSION = get_versions()['version']
BITCOIN = 'bitcoin'
ETHEREUM = 'ethereum'

term = Terminal()

def generate(account_type,
             address_file=None,
             address_qrcode_file=None,
             key_file=None,
             key_qrcode=None):
    if account_type == BITCOIN:
        account = BitcoinAccount.generate()
    elif account_type == ETHEREUM:
        account = EthereumAccount.generate()
    else:
        raise PapyrusException('Invalid account type: {}'.format(account_type))

    passphrase = getpass.getpass('Enter passphrase: ')
    confirmed_passphrase = getpass.getpass('Confirm passphrase: ')

    if passphrase != confirmed_passphrase:
        raise PapyrusException('Passphrases do not match')

    encrypted_key = account.encrypted_priv_key(passphrase)

    print()
    print('Encrypted Private Key: ')
    print(encrypted_key.decode('utf-8'))

    if key_file:
        with open(key_file, 'wb') as f:
            f.write(encrypted_key)

    if key_qrcode:
        img = qrcode.make(encrypted_key)
        img.save(key_qrcode)

    print()
    print('Address: ')
    print(account.address())

    if address_file:
        with open(address_file, 'wb') as f:
            f.write(account.address())

    if address_qrcode_file:
        img = qrcode.make(account.address())
        img.save(address_qrcode_file)


def recover(data,
            key_file=None,
            key_qrcode=None,
            stdout=False,
            stdout_qrcode=False):
    passphrase = getpass.getpass('Enter passphrase: ')

    plain_data = decrypt(passphrase, data)

    if key_file:
        with open(key_file, 'wb') as f:
            f.write(plain_data)

    if key_qrcode:
        img = qrcode.make(plain_data)
        img.save(key_qrcode)

    if stdout:
        print()
        print('Private Key:')
        print(plain_data.decode('utf-8'))

    if stdout_qrcode:
        print()
        qrcode_terminal.draw(plain_data)


def get_key_data(key,
                 key_file,
                 key_qrcode):
    if not key:
        if key_file:
            with open(key_file, 'rb') as f:
                key = f.read()
        elif key_qrcode:
            qr = qrtools.QR()
            qr.decode(key_qrcode)
            key = qr.data
        else:
            key = sys.stdin.read().encode('utf-8')
    return key

if __name__ == '__main__':
    args = docopt(__doc__, version=VERSION)

    if args['--version']:
        print(VERSION)
    else:
        account_type = args['<account_type>'].lower() if args['<account_type>'] else None

        address_file = args['--address_file']
        address_qrcode_file = args['--address_qrcode']

        key = args['--key']
        key_file = args['<encrypted_key_file>'] or args['--key_file']
        key_qrcode = args['--key_qrcode']

        decrypted_key_file = args['<decrypted_key_file>']
        decrypted_key_qrcode = args['--decrypted_key_qrcode']

        stdout = args['--stdout']
        stdout_qrcode = args['--stdout_qrcode']

        try:
            if args['generate']:

                generate(account_type,
                         address_file=address_file,
                         address_qrcode_file=address_qrcode_file,
                         key_file=key_file,
                         key_qrcode=key_qrcode)
            elif args['recover']:
                data = get_key_data(key, key_file, key_qrcode)

                recover(data,
                        key_file=decrypted_key_file,
                        key_qrcode=decrypted_key_qrcode,
                        stdout=stdout,
                        stdout_qrcode=stdout_qrcode)
            else:
                print(__doc__)
        except PapyrusException as e:
            print(term.red(str(e)))
